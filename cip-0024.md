<pre>
  CIP: 24
  Title: Oracled dispensers
  Authors: John "Chiguireitor" Villar
  Discussions-To: https://counterpartytalk.org/t/cip24-oracled-dispensers/6030
  Status: Funding
  Type: Standards
  Created: 2020-12-28
</pre>

## Abstract ##

A modification to the dispensers mechanism to allow a standard dispenser to change
price automatically based on an external feed that acts as an oracle.

## Motivation ##

Usage of dispensers has opened up a lot of possibilities for counterparty users,
letting the exchange of tokens for bitcoin flow more freely. However, the price
assigned to a dispenser is fixed to the given bitcoin amount when opening it,
making price swings problematic for dispenser offerings.

Oracled dispensers would allow pegging the value of a dispenser to a variable
feed multiplier, letting users specify the price of a given dispenser to a
multiplier of a feed.

## Rationale ##

Allowing users to fix a price to an external oracle would allow pegging token
offerings to "real world" assets, allowing sensible prices for long term things
like share selling, token packs and bundles. Usually pegging the value of a
token to a "real world" asset incurs contrived mechanisms like stablecoins or
rebasing of a coin supply. Having a way to easily fix the price of a dispenser
to an external ticker completely removes the need of these schemes that are
prone to manipulation and user confusion.

## Technical implementation ##

Two different parts need to be implemented.

 1) a mechanism to publish feeds that represent price pegging, with these feeds
 getting somehow paid by the users.
 2) a new type of dispenser opening where instead of a fixed bitcoin price, it
 refers to the feeds on point 1 and a multiplier of those feeds.

For this to work, a well known address publishes periodics updates to the feeds
via a broadcast. These updates can be done with a frequency at the sole
discretion of the feed operator.

Whenever a BTC payment reaches a dispenser address, it gets compared to the
latest fee price multiplied by the dispenser amount (if the dispenser if oracled).
If there's a price match then the tokens get dispensed.

Usage of the dispensers can be bound to a subscription service, due to the fact
that operating them costs transactions fees to the operators. Feed operators can
assign a certain asset that needs to be paid to their feed to be used by
dispenser addresses. This usage fee can be determined at their sole discretion
and will be required to be paid on a regular basis determined by the feeds
operators (from a minimum of 144 blocks to MAX_INT blocks, or the special value
of Infinity, which would require only one payment). The asset required by the
feed and amount is also setup via broadcast and can be set at any time.

Feed payments are made by sending the corresponding asset and amount to the
feed address in multiples of the cost periods with the dispenser address as a
memo for the payment being made. If the feed pricing/asset changes, the previous
feed payments get grandfathered in.

An alternative form of payment for feed usage comes from sending the required
asset from the dispenser itself without any memo or from the dispenser creator
in case of "empty address" dispensers. The case of "empty address" dispensers is
only considered on the transactions that open or modify a dispenser and
exclusively for the case where the feed is paid in BTC. Sends from a creator
address to a feed operator that aren't sent along with a dispenser action will
be discarded.

Dispenses from oracled dispensers that don't have a time allotment will be
withheld until the time allotment gets paid, preventing thus an scenario where a
user pays for the tokens but due to lack of payment the dispenser won't dispense.

After time allotment payment, all the withheld dispenses will be released to the
users in one operation up to the time allotment paid.

Time allotment increases the block allowed to be used of the feeds since dispenser
creation to avoid feature exploitation/abuse. This means that payment of the
feed usage is cumulative and not indicative.

# API Changes

### create_dispenser

`create_dispenser` needs changes to allow creating dispensers linked to an
oracle. New types of dispenser open types will be created to differentiate the
type of dispenser being created (between usual dispensers or oracled dispensers).

### create_broadcast

`create_broadcast` needs a new type of broadcast for the price and feed payment
messages. The new type should be able to include:
  * Feed usage price (8 bytes uint)
  * Feed usage asset (8 bytes asset ID)
  * Feed usage time allotment per payment (4 bytes uint), valid values are
  between 144 and MAX_INT and the special value 0 which means infinity.
  * External price (8 bytes uint)
  * External asset name (Always as tail of the broadcast)

All the fields are optional, and are enabled in a 16 bit bitfield mask at the
start of the broadcast message. Having no fields is invalid. The order of the
fields is always the same, regardless if they are enabled or not.

There are additional bit fields possible for feeds:

 * **PRICE_IS_PERCENTAGE** indicates that the price of the feed is a percentage
 based on the total dispensed value. This bit is only valid if Feed usage time
 allotment is 0. If enabled, feed usage price is a percentage with 8 decimal
 places.
 * **ONLY_OWNER_PAYS** only the owner of a dispenser can pay the fees for the
 feed usage. This makes it possible to limit abuse of this feature and is the
 recommended default.

# Database Changes

* `feed_state` table with the timestamped information of the prices and latest
cost and asset for feed usage.

* `feed_payments` table with the latest feed payments.

# Consensus Changes

* All the above functionality
* Sends directed to feed enabled addresses are now to be tracked.
* Sends from an address that create a dispenser on an empty address can pay the
feed on the same transaction as an additional output. This should be accounted
for time allotment and feed usage.

## Backwards Compatibility ##

The oracled dispensers will be a consensus change that will activate at a specific
block to be determined after implementation. All parsing servers will need to
upgrade before this block to maintain consensus.

# Milestones

**Fundraising Goal = 0.25 BTC**

**Milestone #1** (50% - 0.125 BTC)
`dispense`, `create_dispenser` and `create_broadcast` modifications to fit the
new requirements.

**Milestone #2** (50% - 0.125 BTC)
Code merged to master branch and released into a new Counterparty version.

**Stretch goal = 3000 XCP**
Stretch goals are non-obligatory to be funded for the CIP to be carried on, and
can be funded anytime to be activated.

The stretch goals will allow this CIP to also carry on very important non consensus
affecting tasks:

 * Current test suite has broken due to the recent changes and PR, getting this
 working in correct order is a must. (10% - 300 XCP)
 * Continuous integration is broken, and this is needed to validate new PRs before
 allowing them into the main code. (30% - 900 XCP)
 * Making a drop-in regtest mode testing environment available to the general
 public will allow new developers get accustomed to the codebase and ease the
 addition of new coders into the project. (30% - 900 XCP)
 * Creating official support for the xcpjsv2 library on the *npm* code repository
 for everyone to begin using it seamlessly with existing servers. This would also
 include some lingering bug fixes to the mentioned library. (30% - 900 XCP)

## Bounty ##

A bounty custodian has been appointed for collection and awarding of the
milestones completion. User Jeremy Johnson (@j-dog) provided the following
address for bounty collection:

    bc1qz30vrlcprppuv53ct3jgypxp6k5vmfvnmw3cdf

Each milestone should be accompanied by a git commit following CP's coding
standards and requirements.

# Copyright

This document is placed in the public domain.
